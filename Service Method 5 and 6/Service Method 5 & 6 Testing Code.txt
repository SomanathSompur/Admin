 // Method 5 : fetchNotifyDetailsByEventId
    // Scenario 1 : Success()
    @Test
    public void testFetchNotifyDetailsByEventId_Success() {
        // Mock the eventId
        String eventId = "123";

        // Mock the eventNotifies
        List<DmEventNotify> eventNotifies = Collections.emptyList();

        // Stub the mock repository to return eventNotifies when findByEventId is called
        when(dmEventNotifyRepository.findByEventId(Long.parseLong(eventId))).thenReturn(Optional.of(eventNotifies));

        // Call the service method
        Optional<EventResponse> result = documentGeneratorEventStoreService.fetchNotifyDetailsByEventId(eventId);

        // Assertions
        assertTrue(result.isPresent()); // Check if the result is present (not empty)

        EventResponse eventResponse = result.get(); // Get the actual EventResponse object

        assertNotNull(eventResponse); // Check if the EventResponse is not null
        assertNotNull(eventResponse.getEventDataResponse()); // Check if EventDataResponse is not null
        assertFalse(eventResponse.getEventDataResponse().getEventNotifyResponses().isEmpty()); // Check if the list of EventNotifyResponses is not empty
    }

    // Method 5 : fetchNotifyDetailsByEventId
    // Scenario 2 : Optional.of - EmptyEventResponse()
    @Test
    public void testFetchNotifyDetailsByEventId_EmptyEventResponse() {
        // Mock the eventId
        String eventId = "123";          // the variable eventId is being initialized

        // Stub the mock repository to return an empty Optional when findByEventId is called
        when(dmEventNotifyRepository.findByEventId(Long.parseLong(eventId))).thenReturn(Optional.empty());

        // Act, Call the service method
        Optional<EventResponse> result = eventStoreService.fetchNotifyDetailsByEventId(eventId);

        // Assert
        assertFalse(result.isPresent());            // Check if the result is not present (empty)
    }

    
    // Method 5 : fetchNotifyDetailsByEventId
    // Scenario 3 : NotFound()
    @Test
    public void testFetchNotifyDetailsByEventId_NotFound() {
        // Mock the eventId
        String eventId = "123";

        // Stub the mock, the repository to return an empty result when findByEventId is called
        when(dmEventNotifyRepository.findByEventId(Long.parseLong(eventId))).thenReturn(Optional.empty());

        // Call the service method
        Optional<EventResponse> result = documentGeneratorEventStoreService.fetchNotifyDetailsByEventId(eventId);

        // Assertions
        assertFalse(result.isPresent());
    }

    // Method 5 : fetchNotifyDetailsByEventId
    // Scenario 4 : InternalServerError() --> InternalServerError()
    @Test
    public void testFetchNotifyDetailsByEventId_InternalServerError() {
        // Mock the eventId
        String eventId = "123";

        // Stub the mock, the repository to throw an exception when findByEventId is called
        when(dmEventNotifyRepository.findByEventId(Long.parseLong(eventId))).thenThrow(new RuntimeException("Database error"));

        // Call the service method
        Optional<EventResponse> result = documentGeneratorEventStoreService.fetchNotifyDetailsByEventId(eventId);

        // Handle the exception or assert accordingly
        assertFalse(result.isPresent()); // or handle the exception appropriately
    }

    // Method 5 : fetchNotifyDetailsByEventId
    // Scenario 5 : InvalidEventId()  --> Incorrect
    @Test
    public void testFetchNotifyDetailsByEventIdEmpty_InvalidEventId() {
        // Mock the eventId
        String eventId = "invalid"; // Invalid eventId

        // Stub the mock repository to return an empty Optional when findByEventId is called
        when(dmEventNotifyRepository.findByEventId(Long.parseLong(eventId))).thenReturn(Optional.empty());

        // Act, Call the service method
        Optional<EventResponse> result = eventStoreService.fetchNotifyDetailsByEventId(eventId);

        // Assertions
        assertTrue(result.isPresent());
        assertNotNull(result.get().getEventDataResponse());
    }

    // Method 5 : fetchNotifyDetailsByEventId
    // Scenario 6 : EventIdIsNull()
    @Test
    public void testFetchNotifyDetailsByEventIdEmpty_EventIdIsNull() {
        // Mock the eventId
        String eventId = null;    // Set eventId as null

        // Stub the mock repository to return an empty Optional when findByEventId is called
        when(dmEventNotifyRepository.findByEventId(Long.parseLong(eventId))).thenReturn(Optional.empty());

        // Act, Call the service method
        Optional<EventResponse> result = documentGeneratorEventStoreService.fetchNotifyDetailsByEventId(eventId);

        // Assertions
        assertFalse(result.isPresent());
    }

    // Method 5 : fetchNotifyDetailsByEventId
    // Scenario 7 : EventIdIsEmpty()
    @Test
    public void testFetchNotifyDetailsByEventIdEmpty_EventIdIsEmpty() {
        // Mock the eventId
        String eventId = " ";     // Set eventId as empty string

        // Stub the mock repository to return an empty Optional when findByEventId is called
        when(dmEventNotifyRepository.findByEventId(Long.parseLong(eventId))).thenReturn(Optional.empty());

        // Act, Call the service method
        Optional<EventResponse> result = documentGeneratorEventStoreService.fetchNotifyDetailsByEventId(eventId);

        // Assertions
        assertFalse(result.isPresent());
    }

    // Method 5 : fetchNotifyDetailsByEventId
    // Scenario 8 : NoEventNotifies()
    @Test
    public void fetchNotifyDetailsByEventId_NoEventNotifies() {
        // Mock the eventId
        String eventId = "123";

        // Stub the mock repository to return an empty Optional when findByEventId is called
        when(dmEventNotifyRepository.findByEventId(Long.parseLong(eventId))).thenReturn(Optional.of(Collections.emptyList()));

        // Act, Call the service method
        Optional<EventResponse> result = documentGeneratorEventStoreService.fetchNotifyDetailsByEventId(eventId);

        // Assertions
        assertFalse(result.isPresent());
    }

//-------------------------------------------------------------------------------------------------------------------------------------------

    // Method 6 : fetchNotifyDetailsByEventId
    // Scenario 1 : Success()
    @Test
    public void testFetchEventSummaryByDateRange_Success() {
        // Mock input parameters
        String type = "reconcile";
        String startDate = "2023-01-01";
        String endDate = "2023-01-10";

        // Mock data for the repository
        LocalDate dateStart = LocalDate.parse(startDate);
        LocalDate dateEnd = LocalDate.parse(endDate);
        List<Map<String, Object>> dbEvents = new ArrayList<>();
        List<Map<String, Object>> dbCounts = new ArrayList<>();

        // Stub the repository methods
        when(dmEventRepository.findEventsByStartDateAndEndDate(dateStart, dateEnd)).thenReturn(dbEvents);
        when(dmEventRepository.findDocumentEventsByStartDateAndEndDate(dateStart, dateEnd)).thenReturn(dbEvents);
        when(dmEventRepository.findTotalEventCountByStartDateAndEndDate(dateStart, dateEnd)).thenReturn(dbCounts);

        // Call the service method
        Optional<EventSummaryResponse> result = eventStoreService.fetchEventSummaryByDateRange(type, startDate, endDate);

        // Assertions
        assertTrue(result.isPresent());
        assertNotNull(result.get().getEventControlResponse());
    }

    // Method 6 : fetchNotifyDetailsByEventId
    // Scenario 2 : TypeIsEmpty()
    @Test
    public void testFetchEventSummaryByDateRange_TypeIsEmpty() {
        // Mock input parameters
        String type = ""; // Empty type
        String startDate = "2023-01-01";
        String endDate = "2023-01-10";

        // Call the service method
        Optional<EventSummaryResponse> result = eventStoreService.fetchEventSummaryByDateRange(type, startDate, endDate);

        // Assertions
        assertFalse(result.isPresent()); // The result should be an empty Optional
    }

    // Method 6 : fetchNotifyDetailsByEventId
    // Scenario 3 : TypeIsNull()
    @Test
    public void testFetchEventSummaryByDateRange_TypeIsNull() {
        // Mock input parameters
        String type = null; // Type is null
        String startDate = "2023-01-01";
        String endDate = "2023-01-10";

        // Call the service method
        Optional<EventSummaryResponse> result = eventStoreService.fetchEventSummaryByDateRange(type, startDate, endDate);

        // Assertions
        assertFalse(result.isPresent()); // The result should be an empty Optional
    }

    // Method 6 : fetchNotifyDetailsByEventId
    // Scenario 4 : StartDateIsEmpty()
    @Test
    public void testFetchEventSummaryByDateRange_StartDateIsEmpty() {
        // Mock input parameters
        String type = "reconcile";
        String startDate = ""; // Empty startDate
        String endDate = "2023-01-10";

        // Call the service method
        Optional<EventSummaryResponse> result = eventStoreService.fetchEventSummaryByDateRange(type, startDate, endDate);

        // Assertions
        assertFalse(result.isPresent()); // The result should be an empty Optional
    }

    // Method 6 : fetchNotifyDetailsByEventId
    // Scenario 5 : StartDateIsNull()
    @Test
    public void testFetchEventSummaryByDateRange_StartDateIsNull() {
        // Mock input parameters
        String type = "reconcile";
        String startDate = null; // StartDate is null
        String endDate = "2023-01-10";

        // Call the service method
        Optional<EventSummaryResponse> result = eventStoreService.fetchEventSummaryByDateRange(type, startDate, endDate);

        // Assertions
        assertFalse(result.isPresent()); // The result should be an empty Optional
    }

    // Method 6 : fetchNotifyDetailsByEventId
    // Scenario 6 : EndDateIsEmpty()
    @Test
    public void testFetchEventSummaryByDateRange_EndDateIsEmpty() {
        // Mock input parameters
        String type = "reconcile";
        String startDate = "2023-01-01";
        String endDate = ""; // Empty endDate

        // Call the service method
        Optional<EventSummaryResponse> result = eventStoreService.fetchEventSummaryByDateRange(type, startDate, endDate);

        // Assertions
        assertFalse(result.isPresent()); // The result should be an empty Optional
    }

    // Method 6 : fetchNotifyDetailsByEventId
    // Scenario 7 : EndDateIsNull()
    @Test
    public void testFetchEventSummaryByDateRange_EndDateIsNull() {
        // Mock input parameters
        String type = "reconcile";
        String startDate = "2023-01-01";
        String endDate = null; // EndDate is null

        // Call the service method
        Optional<EventSummaryResponse> result = eventStoreService.fetchEventSummaryByDateRange(type, startDate, endDate);

        // Assertions
        assertFalse(result.isPresent()); // The result should be an empty Optional
    }

    // Method 6 : fetchNotifyDetailsByEventId
    // Scenario 8 : AllInputsAreEmpty()
    @Test
    public void testFetchEventSummaryByDateRange_AllInputsAreEmpty() {
        // Mock input parameters
        String type = ""; // Empty type
        String startDate = ""; // Empty startDate
        String endDate = ""; // Empty endDate

        // Call the service method
        Optional<EventSummaryResponse> result = eventStoreService.fetchEventSummaryByDateRange(type, startDate, endDate);

        // Assertions
        assertFalse(result.isPresent()); // The result should be an empty Optional
    }

    // Method 6 : fetchNotifyDetailsByEventId
    // Scenario 9 : AllInputsAreNull()
    @Test
    public void testFetchEventSummaryByDateRange_AllInputsAreNull() {
        // Mock input parameters
        String type = null; // Null type
        String startDate = null; // Null startDate
        String endDate = null; // Null endDate

        // Call the service method
        Optional<EventSummaryResponse> result = eventStoreService.fetchEventSummaryByDateRange(type, startDate, endDate);

        // Assertions
        assertFalse(result.isPresent()); // The result should be an empty Optional
    }

    // Method 6 : fetchNotifyDetailsByEventId
    // Scenario 10 : InvalidDateRange()
    @Test
    public void testFetchEventSummaryByDateRange_InvalidDateRange() {
        // Mock input parameters
        String type = "reconcile";
        String startDate = "2023-01-10"; // End date is before start date
        String endDate = "2023-01-01";

        // Call the service method
        Optional<EventSummaryResponse> result = eventStoreService.fetchEventSummaryByDateRange(type, startDate, endDate);

        // Assertions
        assertFalse(result.isPresent()); // The result should be an empty Optional
    }

    // Method 6 : fetchNotifyDetailsByEventId
    // Scenario 11 : EmptyDBEvents()
    @Test
    public void testFetchEventSummaryByDateRange_EmptyDBEvents() {
        // Mock input parameters
        String type = "reconcile";
        String startDate = "2023-01-01";
        String endDate = "2023-01-10";

        // Mock data for the repository
        LocalDate dateStart = LocalDate.parse(startDate);
        LocalDate dateEnd = LocalDate.parse(endDate);
        List<Map<String, Object>> emptyDBEvents = new ArrayList<>();
        List<Map<String, Object>> dbCounts = new ArrayList<>();

        // Stub the repository methods
        when(dmEventRepository.findEventsByStartDateAndEndDate(dateStart, dateEnd)).thenReturn(emptyDBEvents);
        when(dmEventRepository.findDocumentEventsByStartDateAndEndDate(dateStart, dateEnd)).thenReturn(emptyDBEvents);
        when(dmEventRepository.findTotalEventCountByStartDateAndEndDate(dateStart, dateEnd)).thenReturn(dbCounts);

        // Call the service method
        Optional<EventSummaryResponse> result = eventStoreService.fetchEventSummaryByDateRange(type, startDate, endDate);

        // Assertions
        assertTrue(result.isPresent());
        assertNotNull(result.get().getEventControlResponse());
        assertEquals(0, result.get().getEventControlResponse().getEventControlDatas().size());
    }

    // Method 6 : fetchNotifyDetailsByEventId
    // Scenario 12 : EmptyDBCounts()
    @Test
    public void testFetchEventSummaryByDateRange_EmptyDBCounts() {
        // Mock input parameters
        String type = "reconcile";
        String startDate = "2023-01-01";
        String endDate = "2023-01-10";

        // Mock data for the repository
        LocalDate dateStart = LocalDate.parse(startDate);
        LocalDate dateEnd = LocalDate.parse(endDate);
        List<Map<String, Object>> dbEvents = new ArrayList<>();
        List<Map<String, Object>> emptyDBCounts = new ArrayList<>();

        // Stub the repository methods
        when(dmEventRepository.findEventsByStartDateAndEndDate(dateStart, dateEnd)).thenReturn(dbEvents);
        when(dmEventRepository.findDocumentEventsByStartDateAndEndDate(dateStart, dateEnd)).thenReturn(dbEvents);
        when(dmEventRepository.findTotalEventCountByStartDateAndEndDate(dateStart, dateEnd)).thenReturn(emptyDBCounts);

        // Call the service method
        Optional<EventSummaryResponse> result = eventStoreService.fetchEventSummaryByDateRange(type, startDate, endDate);

        // Assertions
        assertTrue(result.isPresent());
        assertNotNull(result.get().getEventControlResponse());
        assertEquals(0, result.get().getEventControlResponse().getEventControlDatas().size());
    }

    // Method 6 : fetchNotifyDetailsByEventId
    // Scenario 13 : TypeIsInvalid() or type = "12345";
    @Test
    public void testFetchEventSummaryByDateRange_TypeIsInvalid() {
        // Mock input parameters
        String type = "invalidType"; // Type is something other than "reconcile"
        String startDate = "2023-01-01";
        String endDate = "2023-01-10";

        // Call the service method
        Optional<EventSummaryResponse> result = eventStoreService.fetchEventSummaryByDateRange(type, startDate, endDate);

        // Assertions
        assertFalse(result.isPresent()); // Expecting an empty Optional
    }

    // Method 6 : fetchNotifyDetailsByEventId
    // Scenario 14 : StartDateAndEndDateBothSame()
    @Test
    public void testFetchEventSummaryByDateRange_StartDateAndEndDateBothSame() {
        // Mock input parameters
        String type = "reconcile";
        String startDate = "2023-01-10";
        String endDate = "2023-01-10"; // Same as startDate

        // Mock the behavior of dmEventRepository
        when(dmEventRepository.findEventsByStartDateAndEndDate(any(LocalDate.class), any(LocalDate.class)))
                .thenReturn(new ArrayList<>());
        when(dmEventRepository.findDocumentEventsByStartDateAndEndDate(any(LocalDate.class), any(LocalDate.class)))
                .thenReturn(new ArrayList<>());
        when(dmEventRepository.findTotalEventCountByStartDateAndEndDate(any(LocalDate.class), any(LocalDate.class)))
                .thenReturn(new ArrayList<>());

        // Call the service method
        Optional<EventSummaryResponse> result = eventStoreService.fetchEventSummaryByDateRange(type, startDate, endDate);

        // Assertions
        assertTrue(result.isPresent()); // Expecting a non-empty Optional
        assertNotNull(result.get());
        assertNotNull(result.get().getEventControlResponse());
    }

    // Method 6 : fetchNotifyDetailsByEventId
    // Scenario 15 : NoEventSummary() or NoEventSummaryByDateRange()
    @Test
    public void testFetchEventSummaryByDateRange_NoEventSummary() {
        // Mock input parameters
        String type = "reconcile";
        String startDate = "2023-01-01";
        String endDate = "2023-01-10";

        // Mock data for the repository
        LocalDate dateStart = LocalDate.parse(startDate);
        LocalDate dateEnd = LocalDate.parse(endDate);
        List<Map<String, Object>> dbEvents = new ArrayList<>();
        List<Map<String, Object>> dbCounts = new ArrayList<>();

        // Stub the repository methods
        when(dmEventRepository.findEventsByStartDateAndEndDate(dateStart, dateEnd)).thenReturn(dbEvents);
        when(dmEventRepository.findDocumentEventsByStartDateAndEndDate(dateStart, dateEnd)).thenReturn(dbEvents);
        when(dmEventRepository.findTotalEventCountByStartDateAndEndDate(dateStart, dateEnd)).thenReturn(dbCounts);

        // Call the service method
        Optional<EventSummaryResponse> result = eventStoreService.fetchEventSummaryByDateRange(type, startDate, endDate);

        // Assertions
        assertTrue(result.isPresent());
        assertNotNull(result.get().getEventControlResponse());
        assertNotNull(result.get().getEventControlResponse().getEventControlDatas());
        assertTrue(result.get().getEventControlResponse().getEventControlDatas().isEmpty());
    }

    // Method 6 : fetchNotifyDetailsByEventId
    // Scenario 16 : InternalServerError()
    @Test
    public void testFetchEventSummaryByDateRange_InternalServerError() {
        // Mock input parameters
        String type = "reconcile";
        String startDate = "2023-01-01";
        String endDate = "2023-01-10";

        // Mock data for the repository
        LocalDate dateStart = LocalDate.parse(startDate);
        LocalDate dateEnd = LocalDate.parse(endDate);

        // Stub the repository methods to throw an exception
        when(dmEventRepository.findEventsByStartDateAndEndDate(dateStart, dateEnd)).thenThrow(new RuntimeException("Internal Server Error"));

        // Call the service method
        assertThrows(RuntimeException.class, () -> eventStoreService.fetchEventSummaryByDateRange(type, startDate, endDate));
    }

    // Method 6 : fetchNotifyDetailsByEventId
    // Scenario 17 : NoEventControlResponse()
    @Test
    public void testFetchEventSummaryByDateRange_NoEventControlResponse() {
        // Mock input parameters
        String type = "reconcile";
        String startDate = "2023-01-01";
        String endDate = "2023-01-10";

        // Mock data for the repository
        LocalDate dateStart = LocalDate.parse(startDate);
        LocalDate dateEnd = LocalDate.parse(endDate);
        List<Map<String, Object>> dbEvents = new ArrayList<>();
        List<Map<String, Object>> dbCounts = new ArrayList<>();

        // Stub the repository methods
        when(dmEventRepository.findEventsByStartDateAndEndDate(dateStart, dateEnd)).thenReturn(dbEvents);
        when(dmEventRepository.findDocumentEventsByStartDateAndEndDate(dateStart, dateEnd)).thenReturn(dbEvents);
        when(dmEventRepository.findTotalEventCountByStartDateAndEndDate(dateStart, dateEnd)).thenReturn(dbCounts);

        // Call the service method
        Optional<EventSummaryResponse> result = eventStoreService.fetchEventSummaryByDateRange(type, startDate, endDate);

        // Assertions
        assertTrue(result.isPresent());
        assertNull(result.get().getEventControlResponse());   // No event control data is retrieved
    }

    // Method 6 : fetchNotifyDetailsByEventId
    // Scenario 18 : NotFound()
    @Test
    public void testFetchEventSummaryByDateRange_NotFound() {
        // Mock input parameters
        String type = "reconcile";
        String startDate = "2023-01-01";
        String endDate = "2023-01-10";

        // Mock data for the repository
        LocalDate dateStart = LocalDate.parse(startDate);
        LocalDate dateEnd = LocalDate.parse(endDate);

        // Stub the repository methods to return empty lists
        when(dmEventRepository.findEventsByStartDateAndEndDate(dateStart, dateEnd)).thenReturn(new ArrayList<>());
        when(dmEventRepository.findDocumentEventsByStartDateAndEndDate(dateStart, dateEnd)).thenReturn(new ArrayList<>());
        when(dmEventRepository.findTotalEventCountByStartDateAndEndDate(dateStart, dateEnd)).thenReturn(new ArrayList<>());

        // Call the service method
        Optional<EventSummaryResponse> result = eventStoreService.fetchEventSummaryByDateRange(type, startDate, endDate);

        // Assertions
        assertTrue(result.isEmpty());    // To simulate a "Not Found" scenario.
    }